N, a, b = map(int, input().split())
ans = []
max_building = max(a,b)     # 가장 높은 건물 높이

for i in range(1, a) :      # 1 ~ a-1 까지 건물 세우기
    ans.append(i)

ans.append(max_building)    # 가장 높은 건물 세우기

for i in range(b-1, 0, -1): # b-1 ~ 1 까지 건물 세우기
    ans.append(i)

if len(ans) > N :           # 세운 건물이 N보다 많으면
    print(-1)
else :
    print(ans[0], end=' ')  # 제일 왼쪽 건물 하나 먼저 출력
    x = N - len(ans)        # 더 세워야 하는 건물 개수

    for i in range(x):      # 건물 개수 만족할 때 까지 1 출력
        print(1, end=' ')

    for i in range(1, len(ans)):    # 다음 건물 계속 출력
        print(ans[i], end=' ')

'''
a, b를 만족하는 건물 먼저 세우기
N, a, b = 10, 6, 3일때
1~a-1까지 건물을 먼저 짓는다.   [1,2,3,4,5]
그 다음 가장 높은 건물을 짓는다.   max(a,b) = 6    [1,2,3,4,5,6]
b-1 ~ 1까지 건물을 마저 짓는다. [1,2,3,4,5,6,2,1]
10개를 세워야 하는데 9개의 건물이 세워져 있다.
건물 2개를 현재 만족하고 있는 조건을 해치지 않고 추가해야 한다.
출력되는 숫자를 가장 작게 만들기 위해서는 1을 왼쪽 편에 추가해야 한다.
하지만 가장 왼쪽에 1을 추가하는 것이 아닌 1번 인덱스에 추가해야 한다.

    N, a, b = 10, 1, 9 일때
    [9, 8, 7, 6, 5, 4, 3, 2, 1] 이렇게 세워진 건물에 1짜리 건물을 하나 더 추가해야 한다.
    이때 왼쪽에서는 1개의 건물을 봐야 하기 때문에 [1, 9, 8, 7, 6, 5, 4, 3, 2, 1] 이렇게 세우면 조건에 어긋난다.
    그래서 1번 인덱스에 건물을 세우면 [9, 1, 8, 7, 6, 5, 4, 3, 2, 1] 이렇게 조건을 만족하고 가장 작은 숫자를 만들 수 있다.

다시 마저 지어보면 1번 인덱스에 1짜리 건물을 2개 더 세운다.
[1,2,3,4,5,6,2,1] => [1,1,1,2,3,4,5,6,2,1]
왼쪽에서 6개 오른쪽에서 3개가 보이는 건물 중 가장 작은 숫자를 만들었다.
건물을 insert로 1번 인덱스에 계속 추가해도 되지만 바로 출력하는 방법이 훨씬 빠르다.
'''